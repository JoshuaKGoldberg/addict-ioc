import { TypeRegistration } from './type_registration';
import { IRegistrations, IInstances, ITypeRegistrationSettings, IDependencyInjectionContainerConfig, IProvideConfig } from './interfaces';
export declare class DependencyInjectionContainer {
    private _config;
    private _registrations;
    private _instances;
    private _externalConfigProvider;
    constructor(config: IDependencyInjectionContainerConfig);
    private _getDefaultConfiguration();
    clear(): void;
    readonly config: IDependencyInjectionContainerConfig;
    readonly registrations: IRegistrations;
    readonly instances: IInstances;
    readonly externalConfigProvider: IProvideConfig;
    setConfigProvider(configProvider: IProvideConfig): void;
    setDefaults(registrationDefaults: ITypeRegistrationSettings): void;
    private _setDefault(settingKey, value);
    private _isValidBoolean(settingValue);
    register(key: string, type: any): TypeRegistration;
    unregister(key: string): void;
    private _registerTypeByKey(key, type);
    registerFactory(key: string, factoryMethod: any): TypeRegistration;
    registerObject(key: string, object: any): TypeRegistration;
    private _initializeBaseRegistrations();
    private _initializeRegistrationDeclarations();
    private _ensureRegistrationStarted(declaration);
    private _getRegistration(key);
    resolve(key: string, injectionArgs?: Array<any>, config?: any): any;
    private _resolve(key, injectionArgs?, config?, resolvedKeyHistory?, isLazy?);
    private _resolveInstance(registration, injectionArgs, config, resolvedKeyHistory?, isLazy?);
    private _mergeArguments(baseArgs, additionalArgs);
    private _mergeConfig(baseConfig, additionalConfig);
    private _getInstance(registration, injectionArgs, config, resolvedKeyHistory?);
    private _getKeysForInstanceConfigurationsByKey(key);
    private _getKeysForInstanceInjectionArgumentsByKeyAndConfig(key, config);
    private _getAllInstances(key, config?, injectionArgs?);
    private _getNewInstance(registration, injectionArgs?, config?, resolvedKeyHistory?);
    private _bindFunctionsToInstance(registration, instance);
    resolveDependencies(key: string): any[];
    private _resolveDependencies(registration, resolvedKeyHistory?);
    private _isDependencyLazy(registration, dependency);
    private _getDependencyKeyOverwritten(registration, dependency);
    private _createInstance(registration, dependencies, injectionArgs);
    private _createInstanceByFactory(type);
    private _createInstanceByFactoryWithInjection(type, argumentsToBeInjected);
    private _createInstanceByConstructor(type);
    private _createInstanceByConstructorWithInjection(type, argumentsToBeInjected);
    private _injectDependenciesIntoInstance(registration, instance, argumentsToBeInjected);
    private _getPropertyDescriptor(type, key);
    private _injectDependenciesIntoFunction(instance, targetFunction, argumentsToBeInjected);
    private _injectDependenciesIntoProperty(instance, property, argumentsToBeInjected);
    private _getSubscriberRegistrations(key, subscriptionKey);
    private _getSubscriptionFromRegistrationByKey(registration, subscriptionKey, key);
    private _callSubscribers(registration, subscriptionKey, params);
    private _createMissingSubscriber(subscriberRegistration);
    private _callSubscriber(subscribedRegistration, subscriptionKey, subscriberRegistration, subscribedInstance, params);
    private _configureInstance(instance, config);
    private _cacheInstance(key, instance, injectionArgs, config);
    private _getConfig(key);
    private _resolveConfig(key, config);
    validateDependencies(key?: any): void;
    private _validateDependencies(registrationKeys, parentRegistrationHistory?);
    private _historyHasCircularBreak(parentRegistrationHistory, dependencyRegistration);
    private _validateOverwrittenKeys(registration);
    private _validateOverwrittenKey(registration, overwrittenKey, errors);
    private _squashArgumentsToArray(args);
    getKeysByTags(...args: any[]): any[];
    getKeysByAttributes(attributes: Array<any>): any[];
    isRegistered(key: string): boolean;
}
